{"version":3,"sources":["sprintf.js"],"names":["re","not_string","not_bool","not_type","not_primitive","number","numeric_arg","json","not_json","text","modulo","placeholder","key","key_access","index_access","sign","trailing_period_zero","trailing_zeroes","period_zero_exp","zero_before_exp","exp_pos_digits","exp_neg_digits","exp_trailing","sprintf","parse_tree","argv","arg","i","k","ph","pad","pad_character","pad_length","is_positive","hex","high","f","digits","MAXINT","cursor","tree_length","length","output","keys","undefined","Error","param_no","width","parseInt","precision","test","type","Function","isNaN","TypeError","toString","String","fromCharCode","JSON","stringify","parseFloat","toExponential","toFixed","Math","abs","Number","toPrecision","replace","substring","Object","prototype","call","slice","toLowerCase","valueOf","padStart","BigInt","asUintN","toUpperCase","pad_char","charAt","repeat","align","sprintf_format","fmt","sprintf_cache","match","_fmt","arg_names","exec","push","SyntaxError","field_list","replacement_field","field_match","sprintf_parse","arguments","vsprintf","apply","concat","create","exports","window","define"],"mappings":"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","file":"sprintf.min.js","sourcesContent":["/* global window, exports, define */\n\n!function() {\n    'use strict'\n\n    var re = {\n        not_string: /[^s]/,\n        not_bool: /[^t]/,\n        not_type: /[^T]/,\n        not_primitive: /[^v]/,\n        number: /[diefg]/,\n        numeric_arg: /[bcdiefguxX]/,\n        json: /[j]/,\n        not_json: /[^j]/,\n        text: /^[^\\x25]+/,\n        modulo: /^\\x25{2}/,\n        placeholder: /^\\x25(?:([1-9]\\d*)\\$|\\(([^)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+|\\*)?(?:\\.(\\d+|\\*))?([b-gijostTuvxX])/,\n        key: /^([a-z_][a-z_\\d]*)/i,\n        key_access: /^\\.([a-z_][a-z_\\d]*)/i,\n        index_access: /^\\[(\\d+)\\]/,\n        sign: /^[+-]/,\n        trailing_period_zero: /\\.0$/,\n        trailing_zeroes: /(\\.\\d*?[1-9])0+$|\\.0+$/,\n        period_zero_exp: /\\.0*e/,\n        zero_before_exp: /(\\..*[^0])0*e/,\n        exp_pos_digits: /e\\+(\\d)$/,\n        exp_neg_digits: /e-(\\d)$/,\n        exp_trailing: /e([+-])(\\d)$/\n    }\n\n    function sprintf(key) {\n        // `arguments` is not an array, but should be fine for this call\n        return sprintf_format(sprintf_parse(key), arguments)\n    }\n\n    function vsprintf(fmt, argv) {\n        return sprintf.apply(null, [fmt].concat(argv || []))\n    }\n\n    function sprintf_format(parse_tree, argv) {\n        var MAXINT = 0x80000000\n        var DEF_PRECISION = 6\n        var cursor = 1, tree_length = parse_tree.length, arg, output = '', i, k, ph, pad, pad_character, pad_length, is_positive, sign, hex, high, f, digits\n        for (i = 0; i < tree_length; i++) {\n            if (typeof parse_tree[i] === 'string') {\n                output += parse_tree[i]\n            }\n            else if (typeof parse_tree[i] === 'object') {\n                ph = parse_tree[i] // convenience purposes only\n                if (ph.keys) { // keyword argument\n                    arg = argv[cursor]\n                    for (k = 0; k < ph.keys.length; k++) {\n                        if (arg == undefined) {\n                            throw new Error(sprintf('[sprintf] Cannot access property \"%s\" of undefined value \"%s\"', ph.keys[k], ph.keys[k-1]))\n                        }\n                        arg = arg[ph.keys[k]]\n                    }\n                }\n                else if (ph.param_no) { // positional argument (explicit)\n                    arg = argv[ph.param_no]\n                }\n                else if (ph.width === '*') { // asterisk replacement (width)\n                    ph.width = parseInt(argv[cursor++], 10)\n                    arg = argv[cursor++]\n                }\n                else if (ph.precision === '*') { // asterisk replacement (precision)\n                    ph.precision = parseInt(argv[cursor++], 10)\n                    arg = argv[cursor++]\n                }\n                else { // positional argument (implicit)\n                    arg = argv[cursor++]\n                }\n\n                if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {\n                    arg = arg()\n                }\n\n                if (re.numeric_arg.test(ph.type) && (typeof arg !== 'number' && isNaN(arg))) {\n                    throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg))\n                }\n\n                if (re.number.test(ph.type)) {\n                    is_positive = arg >= 0\n                }\n\n                switch (ph.type) {\n                    case 'b':\n                        arg = parseInt(arg, 10).toString(2)\n                        break\n                    case 'c':\n                        arg = String.fromCharCode(parseInt(arg, 10))\n                        break\n                    case 'd':\n                    case 'i':\n                        arg = parseInt(arg, 10)\n                        break\n                    case 'j':\n                        arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0)\n                        break\n                    case 'e':\n                        arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential(DEF_PRECISION)\n                        break\n                    case 'f':\n                        arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg).toFixed(DEF_PRECISION)\n                        break\n                    case 'g':\n                        f = parseFloat(arg)\n                        if (f === 0) {\n                            arg = '0'\n                        }\n                        else if (Math.abs(f) < 0.0001) {\n                            digits = ph.precision ? ph.precision : DEF_PRECISION\n                            digits = digits > 0 ? digits - 1 : 0\n                            arg = f.toExponential(digits)\n                        }\n                        else if (ph.precision && ph.precision < 1) {\n                            arg = f.toFixed(0)\n                        }\n                        else if (ph.precision) {\n                            arg = String(Number(arg.toPrecision(ph.precision)))\n                        }\n                        else {\n                            arg = f.toPrecision(DEF_PRECISION)\n                        }\n                        arg = arg.replace(re.zero_before_exp, '$1e')\n                        arg = arg.replace(re.period_zero_exp, 'e')\n                        arg = arg.replace(re.trailing_zeroes, '$1')\n                        break\n                    case 'o':\n                        arg = (parseInt(arg, 10) >>> 0).toString(8)\n                        break\n                    case 's':\n                        arg = String(arg)\n                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\n                        break\n                    case 't':\n                        arg = String(!!arg)\n                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\n                        break\n                    case 'T':\n                        arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase()\n                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\n                        break\n                    case 'u':\n                        arg = parseInt(arg, 10) >>> 0\n                        break\n                    case 'v':\n                        arg = arg.valueOf()\n                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\n                        break\n                    case 'x':\n                    case 'X':\n                        hex = (parseInt(arg, 10) >>> 0).toString(16)\n                        if (arg && arg.high) {\n                            hex = (parseInt(arg.high, 10) >>> 0).toString(16) + hex.padStart(8, '0')\n                        } else if (parseInt(arg, 10) > MAXINT - 1 || parseInt(arg, 10) < -MAXINT) {\n                            high = BigInt.asUintN(32, BigInt(arg) >> BigInt(32)).toString(16) // eslint-disable-line\n                            hex = parseInt(high, 16) !== 0 ? high + hex.padStart(8, '0') : hex\n                        }\n                        arg = ph.type === 'X' ? hex.toUpperCase() : hex\n                        break\n                }\n                if (ph.type === 'e' || ph.type === 'g') {\n                    arg = arg.replace(re.exp_pos_digits, 'e+$1')\n                    arg = arg.replace(re.exp_neg_digits, 'e-$1')\n                    arg = arg.replace(re.exp_trailing, 'e$10$2')\n                }\n                if (re.json.test(ph.type)) {\n                    output += arg\n                }\n                else {\n                    if (re.number.test(ph.type) && (!is_positive || ph.sign)) {\n                        sign = is_positive ? '+' : '-'\n                        arg = arg.toString().replace(re.sign, '')\n                    }\n                    else {\n                        sign = ''\n                    }\n                    pad_character = ph.pad_char ? ph.pad_char === '0' ? '0' : ph.pad_char.charAt(1) : ' '\n                    pad_length = ph.width - (sign + arg).length\n                    pad = ph.width ? (pad_length > 0 ? pad_character.repeat(pad_length) : '') : ''\n                    output += ph.align ? sign + arg + pad : (pad_character === '0' ? sign + pad + arg : pad + sign + arg)\n                }\n            }\n        }\n        return output\n    }\n\n    var sprintf_cache = Object.create(null)\n\n    function sprintf_parse(fmt) {\n        if (sprintf_cache[fmt]) {\n            return sprintf_cache[fmt]\n        }\n\n        var _fmt = fmt, match, parse_tree = [], arg_names = 0\n        while (_fmt) {\n            if ((match = re.text.exec(_fmt)) !== null) {\n                parse_tree.push(match[0])\n            }\n            else if ((match = re.modulo.exec(_fmt)) !== null) {\n                parse_tree.push('%')\n            }\n            else if ((match = re.placeholder.exec(_fmt)) !== null) {\n                if (match[2]) {\n                    arg_names |= 1\n                    var field_list = [], replacement_field = match[2], field_match = []\n                    if ((field_match = re.key.exec(replacement_field)) !== null) {\n                        field_list.push(field_match[1])\n                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {\n                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {\n                                field_list.push(field_match[1])\n                            }\n                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {\n                                field_list.push(field_match[1])\n                            }\n                            else {\n                                throw new SyntaxError('[sprintf] failed to parse named argument key')\n                            }\n                        }\n                    }\n                    else {\n                        throw new SyntaxError('[sprintf] failed to parse named argument key')\n                    }\n                    match[2] = field_list\n                }\n                else {\n                    arg_names |= 2\n                }\n                if (arg_names === 3) {\n                    throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported')\n                }\n\n                parse_tree.push(\n                    {\n                        placeholder: match[0],\n                        param_no:    match[1],\n                        keys:        match[2],\n                        sign:        match[3],\n                        pad_char:    match[4],\n                        align:       match[5],\n                        width:       match[6],\n                        precision:   match[7],\n                        type:        match[8]\n                    }\n                )\n            }\n            else {\n                throw new SyntaxError('[sprintf] unexpected placeholder')\n            }\n            _fmt = _fmt.substring(match[0].length)\n        }\n        return sprintf_cache[fmt] = parse_tree\n    }\n\n    /**\n     * export to either browser or node.js\n     */\n    /* eslint-disable quote-props */\n    if (typeof exports !== 'undefined') {\n        exports['sprintf'] = sprintf\n        exports['vsprintf'] = vsprintf\n    }\n    if (typeof window !== 'undefined') {\n        window['sprintf'] = sprintf\n        window['vsprintf'] = vsprintf\n\n        if (typeof define === 'function' && define['amd']) {\n            define(function() {\n                return {\n                    'sprintf': sprintf,\n                    'vsprintf': vsprintf\n                }\n            })\n        }\n    }\n    /* eslint-enable quote-props */\n}(); // eslint-disable-line\n"]}